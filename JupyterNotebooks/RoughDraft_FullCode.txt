import numpy as np 
from copy import deepcopy
from qiskit import *

M = 5 # number of lattice sites
t = 1.0 # hopping energy
U = 0.1 # Coulomb potential 
Nu = 3 # number of spin-up electrons
Nd = 3 # number of spin-down electrons

S = 3 # number of Trotter-Suzuki steps
theta = np.random.rand(S, 5) # 5 Hamiltonian terms in each step

empty_circuit = QuantumCircuit(2*M) # initialize circuit

# compose quantum circuit

def compose_initial_circuit(circuit, _M, _Nu, _Nd):
    '''
    This function generates the initial wavefunction \psi_I 
    which is the solution to the non-interacting Hamiltonain H_0
    and depends on the filling factor of the system, i.e. Nu and Nd. 
    This function initializes the spin-up electrons on qubits 0 to
    Nu - 1 and the spin-down electrons on qubits M to M + Nd - 1. 
    '''
    for i in range(_Nu):
        circuit.x(i)
    for i in range(_Nd):
        circuit.x(_M+i)
    return circuit

def compose_ansatz_circuit(circuit, _M, _S, _theta):
    '''
    This function generates the parameterized ansatz wavfunction. 
    The variational parameters theta are given as an input. 
    '''
    # scale theta based on hopping parameter t and Coulomb energy U
    _theta[:, :4] = -0.5*t*_theta[:, :4]
    _theta[:, 4] = U*_theta[:, 4]
    # loop over S Trotter-Suzuki steps
    for j in range(_S):
        # XX and YY interactions: loop over even and odd terms
        for parity in [0]:
            # loop over orbitals
            for i in range(_M-1):
                if i%2 == parity:
                    # loop over spin-up and -down qubits
                    for spin_index in [0, _M]:
                        circuit.cx(spin_index+i, spin_index+i+1)
                        circuit.rx(_theta[j, 2*parity+0], spin_index+i) # theta_j, x(e/o)
                        circuit.h(spin_index+i+1)
                        circuit.cx(spin_index+i+1, spin_index+i)
                        circuit.rx(-_theta[j, 2*parity+1], spin_index+i+1) # theta_j, y(e/o)
                        circuit.cx(spin_index+i+1, spin_index+i)
                        circuit.h(spin_index+i+1)
                        circuit.cx(spin_index+i, spin_index+i+1)
        # barrier
        circuit.barrier()
        # ZZ interactions
        # loop over orbitals
        for i in range(_M):
            circuit.crz(_theta[j, 4], i, _M+i)
    return circuit

def compose_measurement_circuit(circuit, _M, which_term):
    '''
    This function implements the circuit for energy measurement. 
    The argument which_term denotes the Hamiltonian terms:
    xe, xo, ye, yo, and z. 
    '''
    if which_term == "xe":
        for i in range(_M-1):
            circuit.x(i)
            circuit.x(_M+i)
    elif which_term == "xo":
        for i in range(_M-1):
            circuit.x(i+1)
            circuit.x(_M+i+1)
    elif which_term == "ye":
        for i in range(_M-1):
            circuit.y(i)
            circuit.y(_M+i)
    elif which_term == "yo":
        for i in range(_M-1):
            circuit.y(i+1)
            circuit.y(_M+i+1)
    else:
        pass
    return circuit
    
initial_circuit = compose_initial_circuit(deepcopy(empty_circuit), M, Nu, Nd)
ansatz_circuit = compose_ansatz_circuit(deepcopy(empty_circuit), M, S, theta)
measurement_circuit = compose_measurement_circuit(deepcopy(empty_circuit), M, "xe")

complete_circuit = initial_circuit & ansatz_circuit & measurement_circuit
complete_circuit.draw()